<html lang="zh-CN"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  
  <!-- PWA相关meta标签 -->
  <meta name="description" content="一个便捷的地址首字母搜索和管理工具">
  <meta name="theme-color" content="#3b82f6">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="地址备忘录">
  

  
  <!-- manifest.json -->
  <link rel="manifest" href="manifest.json">
  
  <!-- 自定义字体导入 -->
  <style>
    @font-face {
      font-family: '汉字拼音体';
      src: url('./汉字拼音体.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
  </style>
  
  <title>地址首字母搜索备忘录</title>
  <!-- Tailwind CSS v3 (开发环境CDN，生产环境请使用PostCSS插件或Tailwind CLI) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Font Awesome -->
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <!-- pinyin-pro 拼音转换库 -->
  <script src="https://unpkg.com/pinyin-pro@3.18.2/dist/index.js"></script>
  
  <!-- Tailwind 配置 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#007AFF',
            secondary: '#6B7280',
            accent: '#FF9500',
            light: '#F9FAFB',
            dark: '#1F2937'
          },
          fontFamily: {
            sans: ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'sans-serif', '汉字拼音体']
          },
          boxShadow: {
            'card': '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
            'popup': '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)'
          }
        }
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .text-shadow {
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }
      .glass-effect {
        background: rgba(255, 255, 255, 0.7);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }
      .highlight {
        background-color: rgba(255, 240, 0, 0.3);
        padding: 0 2px;
        border-radius: 2px;
      }
      .card-transition {
        transition: all 0.2s ease-in-out;
      }
      .card-transition:hover {
        transform: translateY(-2px);
      }
    }
    
    /* 全局样式 */
    html, body {
      height: 100%;
      -webkit-overflow-scrolling: touch; /* iOS流畅滚动 */
    }
    
    /* 定义CSS变量用于动态高度 */
  :root {
    --safe-area-inset-top: env(safe-area-inset-top);
    --safe-area-inset-bottom: env(safe-area-inset-bottom);
    --available-height: 100vh;
  }
  
  /* 全局防止iOS橡皮筋效果，但保留编辑器滚动功能 */
  html, body {
    overscroll-behavior: none;
    position: fixed;
    width: 100%;
    height: 100%;
  }
  
  /* 确保编辑器可以滚动 */
  #memo-editor {
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
    
    /* 检测并设置安全区域 */
    @supports (padding: env(safe-area-inset-top)) {
      :root {
        --safe-area-inset-top: env(safe-area-inset-top);
        --safe-area-inset-bottom: env(safe-area-inset-bottom);
      }
    }
    
    /* 搜索结果列表 */
    #search-results-list {
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      background-color: #f5f5f5;
      border-radius: 8px;
      margin-top: 8px;
      padding: 8px;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
      position: relative;
      height: 200px;
      max-height: 200px;
    }
    
    /* 自定义滚动条 */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    
    ::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 10px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }
    
    /* iOS 样式输入框 */
    input[type="text"] {
      border-radius: 8px;
      border: 1px solid #e5e7eb;
      padding: 10px 12px;
      font-size: 16px;
      transition: border-color 0.2s;
    }
    
    input[type="text"]:focus {
      border-color: #007AFF;
      outline: none;
      box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
    }
    
    /* 底部安全区域适配 */
    .safe-area-bottom {
      padding-bottom: constant(safe-area-inset-bottom);
      padding-bottom: env(safe-area-inset-bottom);
    }
    
    /* 顶部安全区域适配 */
    .safe-area-top {
      padding-top: constant(safe-area-inset-top);
      padding-top: env(safe-area-inset-top);
    }
    
    /* iOS设备媒体查询 */
    @media screen and (max-width: 768px) {
      /* 适配小屏幕设备 */
      .ios-button {
        min-width: 44px;
        min-height: 44px;
        /* iOS风格按钮效果 */
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
      }
      
      /* 优化文本大小 */
      h1.text-xl {
        font-size: 1.375rem;
      }
      
      /* 优化文本框间距和尺寸 */
      textarea#memo-editor {
        min-height: 300px;
        font-size: 16px; /* 防止iOS缩放 */
      }
      
      /* 增加交互元素间距 */
      .flex.space-x-4 {
        gap: 1rem;
      }
    }
    
    /* iOS设备特殊优化 */
    @media screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3),
           screen and (device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3),
           screen and (device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3),
           screen and (device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) {
      
      /* 适配iPhone X及以上刘海屏设备 */
      header {
        padding-top: calc(1rem + env(safe-area-inset-top));
      }
      
      footer {
        padding-bottom: calc(1rem + env(safe-area-inset-bottom));
        padding-top: 1rem;
        /* 固定底部位置 */
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 100;
      }
      
      /* 确保输入框不会被键盘遮挡 */
      .keyboard-avoidance {
        padding-bottom: 150px; /* 增加底部内边距 */
      }
      
      /* 优化弹窗位置 */
      #file-popup,
      #confirm-popup {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
      }
      
      /* iOS风格输入框 */
      .ios-input {
        font-size: 16px; /* 防止iOS缩放 */
        padding: 12px;
        border-radius: 12px;
      }
      
      /* iOS风格底部栏 */
      .ios-footer {
        border-top-left-radius: 20px;
        border-top-right-radius: 20px;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
      }
    }
  </style>
</head>
<body class="bg-gray-50 font-sans text-dark min-h-screen flex flex-col">
  
  <!-- 主要内容区域 -->
  <main class="flex-grow p-4 keyboard-avoidance">
    <!-- 文本编辑器页面 -->
    <div id="editor-page" class="h-full">
      <textarea id="memo-editor" class="w-full h-full min-h-[300px] p-4 bg-white rounded-lg shadow-sm border border-gray-200 focus:border-primary focus:ring focus:ring-blue-200 focus:outline-none resize-none" placeholder="请输入地址和备注，格式如下：
地址1
备注1
备注2

地址2
备注1

（地址和备注之间用空行分隔，地址放在第一行，备注放在后续行）"></textarea>
    </div>
    
    <!-- 搜索结果页面 (初始隐藏) -->
    <div id="search-results-page" class="h-full hidden">
      <!-- 搜索框（在搜索结果页面置顶显示） -->
      <div id="search-results-search-box" class="relative mb-4">
        <input 
          type="text" 
          id="search-results-input" 
          placeholder="输入地址首字母搜索（如'bjs'查北京）" 
          class="w-full pl-4 pr-10 ios-input" 
          autocapitalize="off"
          autocorrect="off"
          spellcheck="false"
        >
        <button id="search-results-clear-btn" class="absolute right-3 top-1/2 transform -translate-y-1/2 text-secondary hidden ios-button">
          <i class="fa fa-times-circle"></i>
        </button>
      </div>
      
      <!-- 搜索结果标题栏 -->
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-lg font-medium">搜索结果</h2>
        <span id="results-count" class="text-sm text-secondary">已找到0项</span>
      </div>
      
      <!-- 搜索结果列表 -->
      <div id="search-results-list" class="space-y-3 overflow-y-auto" style="max-height: calc(100vh - 250px);">
        <!-- 搜索结果将通过JS动态生成 -->
      </div>
      
      <!-- 未找到结果提示 -->
      <div id="no-results-message" class="hidden text-center py-10">
        <i class="fa fa-search text-4xl text-gray-300 mb-3"></i>
        <p class="text-gray-500">未找到匹配的地址</p>
      </div>
    </div>
    
    <!-- 自动保存提示 -->
    <div id="auto-save-indicator" class="fixed bottom-24 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-70 text-white px-4 py-2 rounded-lg text-sm z-50 hidden">
      <span id="save-status">已自动保存</span>
    </div>
  </main>
  
  <!-- 底部功能区 -->
  <footer class="bg-white shadow-lg p-4 safe-area-bottom ios-footer sticky bottom-0 z-10">
    <div class="flex flex-col space-y-4">
      <!-- 搜索框 -->
      <div class="relative">
        <input 
          type="text" 
          id="search-input" 
          placeholder="输入地址首字母搜索（如'bjs'查北京）" 
          class="w-full pl-4 pr-10 ios-input"
          autocapitalize="off"
          autocorrect="off"
          spellcheck="false"
        >
        <button id="clear-input-btn" class="absolute right-3 top-1/2 transform -translate-y-1/2 text-secondary hidden ios-button">
          <i class="fa fa-times-circle"></i>
        </button>
      </div>
      
      <!-- 按钮容器 - 将在搜索页面隐藏 -->
      <div id="action-buttons-container">
        <!-- 操作按钮 -->
        <div class="flex justify-between items-center">
          <div class="flex space-x-4">
            <button id="file-switch-btn" class="flex items-center justify-center w-12 h-12 rounded-full bg-gray-100 text-dark hover:bg-gray-200 transition-colors ios-button">
              <i class="fa fa-folder-o text-lg"></i>
            </button>
            <button id="new-file-btn" class="flex items-center justify-center w-12 h-12 rounded-full bg-gray-100 text-dark hover:bg-gray-200 transition-colors ios-button">
              <i class="fa fa-plus text-lg"></i>
            </button>
            <button id="rename-file-btn" class="flex items-center justify-center w-12 h-12 rounded-full bg-gray-100 text-dark hover:bg-gray-200 transition-colors ios-button">
              <i class="fa fa-pencil text-lg"></i>
            </button>
            <button id="import-clipboard-btn" class="flex items-center justify-center w-12 h-12 rounded-full bg-gray-100 text-dark hover:bg-gray-200 transition-colors ios-button">
              <i class="fa fa-paste text-lg"></i>
            </button>
          </div>
          
          <button id="save-btn" class="bg-primary text-white px-6 py-3 rounded-full text-sm font-medium shadow-sm hover:bg-blue-600 transition-colors flex items-center ios-button">
            <i class="fa fa-save mr-2"></i> 保存
          </button>
        </div>
      </div>
    </div>
  </footer>
  
  <!-- 文件切换弹窗（初始隐藏） -->
  <div id="file-popup" class="hidden fixed inset-0 bg-black bg-opacity-50 z-30 flex flex-col">
    <div class="bg-white rounded-t-lg flex-grow overflow-auto">
      <div class="p-4 border-b">
        <h3 class="text-lg font-medium">选择文件</h3>
      </div>
      <div id="file-list" class="p-4 space-y-2">
        <!-- 文件列表将通过JS动态生成 -->
      </div>
    </div>
    <div class="bg-white p-4 rounded-b-lg">
      <button id="close-file-popup" class="w-full py-3 bg-gray-100 text-dark rounded-lg text-sm font-medium hover:bg-gray-200 transition-colors">
        取消
      </button>
    </div>
  </div>
  
  <!-- 地址编辑弹窗（初始隐藏） -->
  <div id="edit-popup" class="hidden fixed inset-0 bg-black bg-opacity-50 z-30 flex items-center justify-center p-4">
    <div class="bg-white rounded-lg w-full max-w-md max-h-[80vh] flex flex-col">
      <div class="p-4 border-b flex justify-between items-center">
        <h3 class="text-lg font-medium" id="edit-title">编辑地址</h3>
        <button id="close-edit-popup" class="text-secondary hover:text-dark">
          <i class="fa fa-times"></i>
        </button>
      </div>
      <div class="p-4 flex-grow overflow-auto">
        <textarea id="edit-content" class="w-full h-48 p-3 border rounded-lg text-sm resize-none" placeholder="请输入地址和备注，地址请放在第一行，备注放在后续行"></textarea>
      </div>
      <div class="p-4 border-t flex space-x-3">
        <button id="delete-address-btn" class="flex-1 py-2 bg-gray-100 text-dark rounded-lg text-sm font-medium hover:bg-gray-200 transition-colors">
          删除
        </button>
        <button id="save-address-btn" class="flex-1 py-2 bg-primary text-white rounded-lg text-sm font-medium hover:bg-blue-600 transition-colors">
          保存
        </button>
      </div>
    </div>
  </div>
  
  <!-- 确认弹窗已删除，改用浏览器原生confirm -->
    
  <!-- 提示消息（初始隐藏） -->
  <div id="toast" class="fixed bottom-24 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-70 text-white px-4 py-2 rounded-lg text-sm z-50 hidden">
    <span id="toast-message"></span>
  </div>

  <script>
    // 全局数据存储
    const appData = {
      files: {}, // 存储所有文件 { filename: { content: '...', lastModified: timestamp } }
      currentFile: null, // 当前打开的文件名
      searchQuery: '', // 当前搜索关键词
      debounceTimer: null, // 防抖计时器
      autoSaveTimer: null, // 自动保存计时器
    isModified: false // 内容是否被修改
    };
    
    // DOM 元素
    const elements = {
      // 页面元素
      editorPage: document.getElementById('editor-page'),
      searchResultsPage: document.getElementById('search-results-page'),
      searchResultsList: document.getElementById('search-results-list'),
      resultsCount: document.getElementById('results-count'),
      noResultsMessage: document.getElementById('no-results-message'),
      
      // 编辑器元素
      memoEditor: document.getElementById('memo-editor'),
      autoSaveIndicator: document.getElementById('auto-save-indicator'),
      saveStatus: document.getElementById('save-status'),
      
      // 搜索框
      searchInput: document.getElementById('search-input'),
      clearInputBtn: document.getElementById('clear-input-btn'),
      // 搜索结果页面的搜索框
      searchResultsInput: document.getElementById('search-results-input'),
      searchResultsClearBtn: document.getElementById('search-results-clear-btn'),
      
      // 按钮容器
      actionButtonsContainer: document.getElementById('action-buttons-container'),
      
      // 功能按钮
      fileSwitchBtn: document.getElementById('file-switch-btn'),
      newFileBtn: document.getElementById('new-file-btn'),
      importClipboardBtn: document.getElementById('import-clipboard-btn'),
      saveBtn: document.getElementById('save-btn'),
      renameFileBtn: document.getElementById('rename-file-btn'),
      
      // 文件切换弹窗
      filePopup: document.getElementById('file-popup'),
      fileList: document.getElementById('file-list'),
      closeFilePopup: document.getElementById('close-file-popup'),
      
      // 确认删除弹窗
    // 确认弹窗相关元素已删除，改用浏览器原生confirm
    // cancelConfirmBtn: document.getElementById('cancel-confirm-btn'),
    // confirmActionBtn: document.getElementById('confirm-action-btn'),
      
      // 提示消息
      toast: document.getElementById('toast'),
      toastMessage: document.getElementById('toast-message')
    };
    
    // 初始化应用
    function initApp() {
      // 从本地存储加载数据
      loadDataFromLocalStorage();
      
      // 如果没有文件，创建一个默认文件
      if (Object.keys(appData.files).length === 0) {
        createNewFile();
      } else {
        // 打开最近修改的文件
        const recentFiles = Object.keys(appData.files).sort((a, b) => {
          return appData.files[b].lastModified - appData.files[a].lastModified;
        });
        openFile(recentFiles[0]);
      }
      
      // 绑定事件
      bindEvents();
      
      // 页面加载后自动激活搜索框
      setTimeout(() => {
        elements.searchInput.focus();
      }, 100);
      
      // 阻止iOS橡皮筋效果，但保留编辑器和搜索结果列表的滚动功能
      function preventRubberBandEffect() {
        let startY;
        document.addEventListener('touchstart', function(e) {
          startY = e.touches[0].pageY;
        }, { passive: true });
        
        document.addEventListener('touchmove', function(e) {
          // 检查是否在编辑器或搜索结果列表区域内，如果是则不阻止滚动
          if ((elements.memoEditor && elements.memoEditor.contains(e.target)) || 
              (elements.searchResultsList && elements.searchResultsList.contains(e.target))) {
            return; // 允许编辑器和搜索结果列表滚动
          }
          
          const currentY = e.touches[0].pageY;
          const scrollTop = window.scrollY;
          
          // 顶部下拉和底部上拉时阻止默认行为
          if ((scrollTop === 0 && currentY > startY) || 
              (scrollTop + window.innerHeight === document.documentElement.scrollHeight && currentY < startY)) {
            e.preventDefault();
          }
        }, { passive: false });
      }
      
      // 调用阻止橡皮筋效果函数
      preventRubberBandEffect();
      
      // 处理iOS键盘弹出事件
      function handleKeyboardVisibility() {
        // 搜索框聚焦时处理
        elements.searchInput.addEventListener('focus', function() {
          // 强制滚动到顶部
          window.scrollTo(0, 0);
          
          // 添加定时调整，确保键盘弹出后布局正确
          setTimeout(() => {
            window.scrollTo(0, 0);
          }, 300);
        });
        
        // 搜索结果页面的搜索框聚焦时处理
        elements.searchResultsInput.addEventListener('focus', function() {
          // 强制滚动到顶部
          window.scrollTo(0, 0);
          
          // 添加定时调整，确保键盘弹出后布局正确
          setTimeout(() => {
            window.scrollTo(0, 0);
          }, 300);
        });
        
        // 输入框内容变化时也调整布局
        elements.searchInput.addEventListener('input', function() {
          setTimeout(() => {
            window.scrollTo(0, 0);
          }, 100);
        });
        
        elements.searchResultsInput.addEventListener('input', function() {
          setTimeout(() => {
            window.scrollTo(0, 0);
          }, 100);
        });
        
        // 点击页面其他区域时恢复默认样式，但排除编辑器区域
        document.addEventListener('click', function(e) {
          if (!e.target.closest('input') && !e.target.closest('#memo-editor')) {
            setTimeout(() => {
              window.scrollTo(0, 0);
            }, 100);
          }
        });
      }
      
      // 调用处理键盘可见性的函数
      handleKeyboardVisibility();
    }
    
    // 绑定编辑器内容到当前文件
    function bindEditorToFile() {
      if (appData.currentFile) {
        elements.memoEditor.value = appData.files[appData.currentFile].content || '';
        appData.isModified = false;
      }
    }
    
    // 从本地存储加载数据
    function loadDataFromLocalStorage() {
      const savedData = localStorage.getItem('addressBookData');
      if (savedData) {
        appData.files = JSON.parse(savedData);
      }
    }
    
    // 保存数据到本地存储
    function saveDataToLocalStorage() {
      localStorage.setItem('addressBookData', JSON.stringify(appData.files));
    }
    
    // 注释掉重复的绑定事件函数（已在前面定义）
    
    // 处理搜索框焦点事件
    function handleSearchFocus() {
      const query = elements.searchInput.value.trim().toLowerCase().replace(/[^a-z]/g, '');
      if (query) {
        appData.searchQuery = query;
        performSearch();
      }
    }
    
    // 处理搜索输入
    function handleSearchInput() {
      const query = elements.searchInput.value.trim().toLowerCase().replace(/[^a-z]/g, '');
      appData.searchQuery = query;
      
      // 显示/隐藏清空按钮
      elements.clearInputBtn.classList.toggle('hidden', !query);
      
      // 如果搜索结果页面已显示，同步到搜索结果页面的搜索框
      if (!elements.searchResultsPage.classList.contains('hidden')) {
        elements.searchResultsInput.value = query;
        elements.searchResultsClearBtn.classList.toggle('hidden', !query);
      }
      
      // 如果没有搜索词，显示编辑器页面
      if (!query) {
        showEditorPage();
        return;
      }
      
      // 防抖处理
      if (appData.debounceTimer) {
        clearTimeout(appData.debounceTimer);
      }
      
      appData.debounceTimer = setTimeout(() => {
        performSearch();
      }, 300);
    }
    
    // 处理编辑器输入
    function handleEditorInput() {
      appData.isModified = true;
      
      // 更新当前文件内容
      if (appData.currentFile) {
        appData.files[appData.currentFile].content = elements.memoEditor.value;
        
        // 设置自动保存
        if (appData.autoSaveTimer) {
          clearTimeout(appData.autoSaveTimer);
        }
        
        appData.autoSaveTimer = setTimeout(() => {
          if (appData.isModified) {
            saveCurrentFile(true);
          }
        }, 2000); // 2秒后自动保存
      }
    }
    
    // 保存当前文件
    function saveCurrentFile(isAutoSave = false) {
      if (!appData.currentFile || !appData.isModified) return;
      
      // 更新文件最后修改时间
      appData.files[appData.currentFile].lastModified = new Date().getTime();
      
      // 保存数据到本地存储
      saveDataToLocalStorage();
      
      appData.isModified = false;
      
      // 显示保存提示
      if (isAutoSave) {
        showAutoSaveIndicator('已自动保存');
      } else {
        showToast('已保存');
      }
    }
    
    // 切换文件弹窗
    function toggleFilePopup() {
      if (elements.filePopup) {
        elements.filePopup.classList.toggle('hidden');
        if (!elements.filePopup.classList.contains('hidden')) {
          renderFileList();
        }
      } else {
        console.error('filePopup element not found');
      }
    }
    
    // 关闭文件弹窗 - 增强版本，确保弹窗正确关闭
    function closeFilePopup() {
      console.log('Closing file popup');
      if (elements.filePopup) {
        // 确保弹窗被正确隐藏
        elements.filePopup.classList.add('hidden');
        // 可选：添加过渡效果
        elements.filePopup.style.transition = 'opacity 0.2s ease';
        elements.filePopup.style.opacity = '0';
        setTimeout(() => {
          elements.filePopup.style.opacity = '1';
        }, 200);
      } else {
        console.error('filePopup element not found');
      }
    }
    
    // 渲染文件列表
    function renderFileList() {
      if (!elements.fileList) {
        console.error('fileList element not found');
        return;
      }
      
      elements.fileList.innerHTML = '';
      
      // 保持文件顺序固定，不进行排序
      const files = Object.keys(appData.files);
      
      files.forEach(filename => {
        const fileItem = document.createElement('div');
        fileItem.className = `p-3 rounded-lg flex justify-between items-center ${appData.currentFile === filename ? 'bg-blue-50 text-primary' : 'hover:bg-gray-50 cursor-pointer'}`;
        
        // 点击行切换文件
        if (appData.currentFile !== filename) {
          fileItem.addEventListener('click', () => {
            openFile(filename);
            closeFilePopup();
          });
        }
        
        const fileInfo = document.createElement('div');
        fileInfo.className = 'flex items-center';
        
        const fileIcon = document.createElement('i');
        fileIcon.className = 'fa fa-file-text-o mr-3';
        
        const fileName = document.createElement('div');
        fileName.className = 'text-sm';
        fileName.textContent = filename;
        
        fileInfo.appendChild(fileIcon);
        fileInfo.appendChild(fileName);
        
        const fileActions = document.createElement('div');
        fileActions.className = 'flex items-center space-x-2';
        
        if (appData.currentFile === filename) {
          const currentBadge = document.createElement('span');
          currentBadge.className = 'text-xs bg-primary text-white px-2 py-1 rounded-full';
          currentBadge.textContent = '当前';
          fileActions.appendChild(currentBadge);
        }
        
        // 添加删除按钮
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'text-xs text-red-500';
        deleteBtn.textContent = '删除';
        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          handleDeleteFile(filename);
        });
        fileActions.appendChild(deleteBtn);
        
        fileItem.appendChild(fileInfo);
        fileItem.appendChild(fileActions);
        
        elements.fileList.appendChild(fileItem);
      });
    }
    
    // 绑定事件
    function bindEvents() {
      // 搜索框事件
      elements.searchInput.addEventListener('input', handleSearchInput);
      elements.searchInput.addEventListener('focus', handleSearchFocus);
      elements.clearInputBtn.addEventListener('click', clearSearchInput);
      
      // 搜索结果页面搜索框事件
      elements.searchResultsInput.addEventListener('input', handleSearchResultsInput);
      elements.searchResultsClearBtn.addEventListener('click', clearSearchResultsInput);
      
      // 编辑器事件
      elements.memoEditor.addEventListener('input', handleEditorInput);
      
      // 功能按钮事件
      elements.fileSwitchBtn.addEventListener('click', toggleFilePopup);
      elements.newFileBtn.addEventListener('click', handleNewFile);
      elements.importClipboardBtn.addEventListener('click', handleImportClipboard);
      elements.saveBtn.addEventListener('click', saveCurrentFile);
      
      // 重命名按钮事件
      if (elements.renameFileBtn) {
        elements.renameFileBtn.addEventListener('click', handleRenameFile);
      }
      
      // 文件切换弹窗事件 - 增强版本，确保取消按钮正常工作
      if (elements.closeFilePopup) {
        elements.closeFilePopup.addEventListener('click', function(e) {
          e.stopPropagation(); // 阻止事件冒泡
          closeFilePopup();
        });
      } else {
        console.error('closeFilePopup element not found');
      }
      
      // 为文件弹窗添加点击空白区域关闭功能
      if (elements.filePopup) {
        elements.filePopup.addEventListener('click', function(e) {
          if (e.target === elements.filePopup) {
            closeFilePopup();
          }
        });
      }
      
      // 确认弹窗按钮事件监听已删除，改用浏览器原生confirm
    }
    
    // 显示自动保存提示
    function showAutoSaveIndicator(message) {
      elements.saveStatus.textContent = message;
      elements.autoSaveIndicator.classList.remove('hidden');
      
      setTimeout(() => {
        elements.autoSaveIndicator.classList.add('hidden');
      }, 1500);
    }
    
    // 高亮搜索结果
    function highlightSearchResults() {
      const query = appData.searchQuery;
      const content = elements.memoEditor.value;
      
      if (!query) {
        // 移除所有高亮
        elements.memoEditor.value = content;
        return;
      }
      
      // 解析地址内容
      const addresses = parseAddressContent(content);
      const filteredAddresses = searchAddresses(addresses, query);
      
      if (filteredAddresses.length === 0) {
        showToast('未找到匹配地址');
        return;
      }
      
      // 收集所有匹配的地址
      const matchingAddresses = filteredAddresses.map(item => item.address);
      
      // 在编辑器中高亮匹配的地址
      let newContent = content;
      
      matchingAddresses.forEach(address => {
        // 创建正则表达式，全局匹配地址
        const regex = new RegExp(address.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
        // 使用<span>标签包裹匹配的地址（注意：textarea不支持HTML标签）
        // 这里我们使用特殊字符标记，然后在可视化时处理
        newContent = newContent.replace(regex, `【${address}】`);
      });
      
      // 由于textarea不支持HTML标签，我们使用特殊字符标记
      // 实际应用中，如果需要可视化高亮，应该使用contenteditable的div代替textarea
      elements.memoEditor.value = newContent;
      
      // 提示找到的匹配数量
      showToast(`找到 ${filteredAddresses.length} 个匹配地址`);
    }
    
    // 清空搜索输入
    function clearSearchInput() {
      elements.searchInput.value = '';
      appData.searchQuery = '';
      elements.clearInputBtn.classList.add('hidden');
      
      // 如果搜索结果页面已显示，也清空该页面的搜索框
      if (!elements.searchResultsPage.classList.contains('hidden')) {
        elements.searchResultsInput.value = '';
        elements.searchResultsClearBtn.classList.add('hidden');
      }
      
      showEditorPage();
    }
    
    // 执行搜索 - 搜索所有备忘录文件
    function performSearch() {
      const query = appData.searchQuery;
      
      // 遍历所有文件，收集所有地址
      let allAddresses = [];
      Object.keys(appData.files).forEach(fileName => {
        const file = appData.files[fileName];
        const fileAddresses = parseAddressContent(file.content);
        // 为每个地址添加文件名信息，方便显示来源
        fileAddresses.forEach(address => {
          address.sourceFile = fileName;
        });
        allAddresses = allAddresses.concat(fileAddresses);
      });
      
      // 搜索匹配的地址
      const filteredAddresses = searchAddresses(allAddresses, query);
      
      // 显示搜索结果页面
      showSearchResultsPage(filteredAddresses);
    }
    
    // 处理搜索结果页面的搜索输入
    function handleSearchResultsInput() {
      const query = elements.searchResultsInput.value.trim().toLowerCase().replace(/[^a-z]/g, '');
      appData.searchQuery = query;
      
      // 同步到底部搜索框
      elements.searchInput.value = query;
      
      // 显示/隐藏清空按钮
      elements.searchResultsClearBtn.classList.toggle('hidden', !query);
      elements.clearInputBtn.classList.toggle('hidden', !query);
      
      // 如果没有搜索词，显示编辑器页面
      if (!query) {
        showEditorPage();
        return;
      }
      
      // 防抖处理
      if (appData.debounceTimer) {
        clearTimeout(appData.debounceTimer);
      }
      
      appData.debounceTimer = setTimeout(() => {
        performSearch();
      }, 300);
    }
    
    // 清空搜索结果页面的搜索输入
    function clearSearchResultsInput() {
      elements.searchResultsInput.value = '';
      elements.searchResultsClearBtn.classList.add('hidden');
      clearSearchInput();
    }
    
    // 显示搜索结果页面
    function showSearchResultsPage(results) {
      // 切换到搜索结果页面
      elements.editorPage.classList.add('hidden');
      elements.searchResultsPage.classList.remove('hidden');
      
      // 隐藏按钮容器
      if (elements.actionButtonsContainer) {
        elements.actionButtonsContainer.classList.add('hidden');
      }
      
      // 同步搜索框内容
      elements.searchResultsInput.value = appData.searchQuery;
      elements.searchResultsClearBtn.classList.toggle('hidden', !appData.searchQuery);
      
      // 更新结果数量
      elements.resultsCount.textContent = `已找到${results.length}项`;
      
      // 渲染搜索结果
      renderSearchResults(results);
      
      // 显示/隐藏无结果提示
      elements.searchResultsList.classList.toggle('hidden', results.length === 0);
      elements.noResultsMessage.classList.toggle('hidden', results.length > 0);
    }
    
    // 显示编辑器页面
    function showEditorPage() {
      elements.searchResultsPage.classList.add('hidden');
      elements.editorPage.classList.remove('hidden');
      
      // 显示按钮容器
      if (elements.actionButtonsContainer) {
        elements.actionButtonsContainer.classList.remove('hidden');
      }
    }
    
    // 高亮匹配的文本 - 优化版本
    function highlightMatchingText(text, query) {
      if (!query || !text) return text;
      
      const lowerQuery = query.toLowerCase();
      const lowerText = text.toLowerCase();
      
      // 快速路径：直接文本匹配，性能最高
      if (lowerText.includes(lowerQuery)) {
        // 使用字符串操作而非正则，避免正则转义问题
        let result = '';
        let lastIndex = 0;
        let matchPos = 0;
        
        while ((matchPos = lowerText.indexOf(lowerQuery, lastIndex)) !== -1) {
          // 添加匹配前的文本
          result += text.substring(lastIndex, matchPos);
          // 添加带高亮的匹配文本
          result += `<span class="bg-yellow-200 px-0.5 py-0.5 rounded">${text.substring(matchPos, matchPos + lowerQuery.length)}</span>`;
          // 更新位置
          lastIndex = matchPos + lowerQuery.length;
        }
        
        // 添加最后剩余的文本
        result += text.substring(lastIndex);
        return result;
      }
      
      // 获取文本中的所有词语（排除完整地址）
      let words = splitAddressIntoWords(text);
      words = words.filter(word => word !== text);
      
      let highlightedText = text;
      let hasMatch = false;
      
      // 创建高亮包装函数
      const wrapWithHighlight = (match) => {
        hasMatch = true;
        return `<span class="bg-yellow-200 px-0.5 py-0.5 rounded">${match}</span>`;
      };
      
      // 对每个词语进行检查
      words.forEach(word => {
        // 检查词语的拼音首字母是否包含搜索关键词
        const wordPinyin = generatePinyinIndex(word).toLowerCase();
        if (wordPinyin.includes(lowerQuery)) {
          // 对匹配的词语进行高亮，使用更安全的正则转义
          const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const regex = new RegExp(escapedWord, 'gi');
          highlightedText = highlightedText.replace(regex, wrapWithHighlight);
        }
        // 检查词语本身是否包含搜索关键词
        else if (word.toLowerCase().includes(lowerQuery)) {
          const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const regex = new RegExp(escapedQuery, 'gi');
          highlightedText = highlightedText.replace(regex, wrapWithHighlight);
        }
      });
      
      // 如果没有匹配到任何词语，尝试拼音首字母匹配
      if (!hasMatch) {
        const textPinyin = generatePinyinIndex(text).toLowerCase();
        if (textPinyin.includes(lowerQuery)) {
          // 找到匹配的拼音首字母对应的字符范围
          const matchPos = textPinyin.indexOf(lowerQuery);
          const matchEndPos = matchPos + lowerQuery.length;
          
          // 将拼音位置映射到原文本中的中文字符
          const matchPositions = [];
          let pinyinIndex = 0;
          
          for (let i = 0; i < text.length && pinyinIndex < matchEndPos; i++) {
            if (/[\u4e00-\u9fa5]/.test(text[i])) {
              if (pinyinIndex >= matchPos && pinyinIndex < matchEndPos) {
                matchPositions.push(i);
              }
              pinyinIndex++;
            }
          }
          
          // 如果找到了匹配位置，高亮这些字符
          if (matchPositions.length > 0) {
            // 从后往前替换，避免位置偏移
            for (let i = matchPositions.length - 1; i >= 0; i--) {
              const pos = matchPositions[i];
              highlightedText = 
                highlightedText.substring(0, pos) +
                `<span class="bg-yellow-200 px-0.5 py-0.5 rounded">${text[pos]}</span>` +
                highlightedText.substring(pos + 1);
            }
          }
        }
      }
      
      return highlightedText;
    }
    
    // 渲染搜索结果
    function renderSearchResults(results) {
      elements.searchResultsList.innerHTML = '';
      
      // 获取搜索关键词
      const query = appData.searchQuery.toLowerCase();
      
      results.forEach(item => {
        const resultItem = document.createElement('div');
        resultItem.className = 'bg-white rounded-lg shadow-sm p-4 card-transition';
        
        // 显示来源文件信息
        if (item.sourceFile) {
          const sourceFileElement = document.createElement('div');
          sourceFileElement.className = 'text-xs text-blue-500 mb-1';
          sourceFileElement.textContent = `来源: ${item.sourceFile}`;
          resultItem.appendChild(sourceFileElement);
        }
        
        // 地址标题 - 高亮匹配部分
        const addressTitle = document.createElement('h3');
        addressTitle.className = 'text-base font-medium mb-1';
        addressTitle.innerHTML = highlightMatchingText(item.address, query);
        
        // 备注内容 - 高亮匹配部分
        const notesContent = document.createElement('div');
        notesContent.className = 'text-sm text-gray-600 mt-2';
        
        // 处理备注内容，显示前几行
        if (item.notes) {
          const noteLines = item.notes.split('\n');
          noteLines.forEach((line, index) => {
            if (index < 3) { // 只显示前3行备注
              const noteLine = document.createElement('p');
              noteLine.className = 'mb-1';
              noteLine.innerHTML = highlightMatchingText(line, query);
              notesContent.appendChild(noteLine);
            } else if (index === 3) {
              const moreNote = document.createElement('p');
              moreNote.className = 'text-xs text-gray-400';
              moreNote.textContent = `...还有${noteLines.length - 3}行`;
              notesContent.appendChild(moreNote);
            }
          });
        }
        
        // 组装结果项
        resultItem.appendChild(addressTitle);
        resultItem.appendChild(notesContent);
        
        // 添加点击事件
        resultItem.addEventListener('click', () => {
          // 点击结果项时跳转到编辑器并高亮对应地址
          // 如果有来源文件信息，先打开该文件
          if (item.sourceFile) {
            openFile(item.sourceFile);
          }
          scrollToAddress(item.address);
        });
        
        elements.searchResultsList.appendChild(resultItem);
      });
    }
    
    // 滚动到指定地址记录 - 改进版本，使用更精确的定位算法
    function scrollToAddress(address) {
      // 切换回编辑器页面
      showEditorPage();
      
      // 使用setTimeout确保页面完全切换后再执行后续操作
      setTimeout(() => {
        // 在编辑器中查找并定位到地址
        const content = elements.memoEditor.value;
        
        // 改进的地址查找逻辑：使用正则表达式确保找到的是完整的地址行
        const addressRegex = new RegExp('(^|\n\n)' + address.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
        let match = addressRegex.exec(content);
        
        // 如果没有找到精确匹配，尝试更宽松的匹配
        if (!match) {
          const looseRegex = new RegExp(address.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
          match = looseRegex.exec(content);
        }
        
        if (match) {
          // 获取地址的起始位置（考虑到可能捕获的换行符）
          const addressIndex = match.index + (match[1] ? match[1].length : 0);
          
          // 设置光标位置到地址开头
          elements.memoEditor.focus();
          elements.memoEditor.setSelectionRange(addressIndex, addressIndex);
          
          // 使用更精确的方法来计算滚动位置
          // 创建一个临时的div来测量文本高度
          const tempDiv = document.createElement('div');
          tempDiv.style.position = 'absolute';
          tempDiv.style.top = '-9999px';
          tempDiv.style.left = '-9999px';
          tempDiv.style.width = elements.memoEditor.offsetWidth + 'px';
          tempDiv.style.font = getComputedStyle(elements.memoEditor).font;
          tempDiv.style.lineHeight = getComputedStyle(elements.memoEditor).lineHeight;
          tempDiv.style.whiteSpace = 'pre-wrap';
          tempDiv.textContent = content.substring(0, addressIndex);
          document.body.appendChild(tempDiv);
          
          // 获取实际文本高度
          const scrollHeight = tempDiv.offsetHeight;
          document.body.removeChild(tempDiv);
          
          // 设置滚动位置，将地址放在视图的1/4处
          const targetScrollTop = Math.max(0, scrollHeight - (elements.memoEditor.clientHeight / 4));
          elements.memoEditor.scrollTop = targetScrollTop;
          
          // 使用requestAnimationFrame确保浏览器渲染完成后再进行微调
          requestAnimationFrame(() => {
            // 再次微调，确保地址在正确位置
            elements.memoEditor.scrollTop = targetScrollTop;
            
            // 对于很长的内容，添加额外的调整确保定位准确
            requestAnimationFrame(() => {
              // 确保光标可见
              elements.memoEditor.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
          });
        }
      }, 150); // 稍微增加延迟，确保页面完全切换
    }
    

    


    


    
    // 处理删除文件
    function handleDeleteFile(filename) {
      // 如果是当前打开的文件，需要先关闭
      if (appData.currentFile === filename) {
        // 如果文件只有一个，不允许删除
        if (Object.keys(appData.files).length === 1) {
          showToast('至少需要保留一个文件');
          return;
        }
        
        // 使用浏览器原生confirm弹窗
        if (confirm(`删除"${filename}"后，所有内容将丢失`)) {
          // 执行删除
          delete appData.files[filename];
          saveDataToLocalStorage();
          
          // 打开最近的文件
          const recentFiles = Object.keys(appData.files).sort((a, b) => {
            return appData.files[b].lastModified - appData.files[a].lastModified;
          });
          
          if (recentFiles.length > 0) {
            openFile(recentFiles[0]);
          } else {
            createNewFile();
          }
          
          closeFilePopup();
          showToast('文件已删除');
        }
      } else {
        // 使用浏览器原生confirm弹窗
        if (confirm(`删除"${filename}"后，所有内容将丢失`)) {
          // 执行删除
          delete appData.files[filename];
          saveDataToLocalStorage();
          
          // 重新渲染文件列表
          renderFileList();
          
          showToast('文件已删除');
        }
      }
    }
    
    // 处理新建文件
    function handleNewFile() {
      // 检查当前文件是否有未保存的更改
      if (appData.currentFile && appData.isModified) {
        // 使用浏览器原生confirm弹窗
        if (confirm('当前文件有未保存的更改，是否继续创建新文件？')) {
          createNewFile();
        }
      } else {
        createNewFile();
      }
    }
    
    // 创建新文件
    function createNewFile() {
      const timestamp = new Date().getTime();
      
      // 查找最大的备忘录序号
      let maxNumber = 0;
      for (const filename in appData.files) {
        const match = filename.match(/^新备忘录(\d+)$/);
        if (match) {
          const number = parseInt(match[1], 10);
          if (number > maxNumber) {
            maxNumber = number;
          }
        }
      }
      
      // 生成新的文件名
      const defaultName = `新备忘录${maxNumber + 1}`;
      
      appData.files[defaultName] = {
        content: '',
        lastModified: timestamp
      };
      saveDataToLocalStorage();
      openFile(defaultName);
      showToast('新文件已创建');
    }
    
    // 打开文件
    function openFile(filename) {
      if (!appData.files[filename]) return;
      
      // 检查当前文件是否有未保存的更改
      if (appData.currentFile && appData.isModified) {
        // 使用浏览器原生confirm弹窗
        if (confirm('当前文件有未保存的更改，是否继续？')) {
          doOpenFile(filename);
        }
      } else {
        doOpenFile(filename);
      }
    }
    
    // 执行打开文件操作
    function doOpenFile(filename) {
      appData.currentFile = filename;
      
      // 更新文件最后修改时间
      appData.files[filename].lastModified = new Date().getTime();
      saveDataToLocalStorage();
      
      // 绑定编辑器内容
      bindEditorToFile();
      
      // 清空搜索
      clearSearchInput();
      
      // 关闭文件弹窗
      closeFilePopup();
    }
    
    // 处理文件重命名
    function handleRenameFile() {
      if (!appData.currentFile) {
        showToast('没有当前打开的文件');
        return;
      }
      
      const newFileName = prompt('请输入新的文件名:', appData.currentFile);
      
      if (newFileName === null) {
        // 用户取消操作
        return;
      }
      
      const trimmedName = newFileName.trim();
      
      if (!trimmedName) {
        showToast('文件名不能为空');
        return;
      }
      
      if (trimmedName === appData.currentFile) {
        // 文件名没有变化
        return;
      }
      
      if (appData.files[trimmedName]) {
        showToast('文件名已存在');
        return;
      }
      
      // 重命名文件
      appData.files[trimmedName] = appData.files[appData.currentFile];
      delete appData.files[appData.currentFile];
      
      // 更新当前文件名
      appData.currentFile = trimmedName;
      
      // 保存数据
      saveDataToLocalStorage();
      showToast('文件已重命名');
    }
    

    
    // 处理导入剪切板 - 使用浏览器原生confirm弹窗
    function handleImportClipboard() {
      showToast('准备导入剪贴板内容...');
      
      if (!navigator.clipboard) {
        showToast('您的浏览器不支持剪贴板功能');
        return;
      }
      
      // 在移动设备上添加额外的错误处理
      navigator.clipboard.readText()
        .then(text => {
          if (!text.trim()) {
            showToast('剪切板为空');
            return;
          }
          
          // 获取文本的第一行作为文件名预览
          const firstLine = text.split('\n')[0].trim();
          let fileNamePreview = sanitizeFileName(firstLine);
          if (!fileNamePreview || fileNamePreview.length < 2) {
            fileNamePreview = '新备忘录';
          }
          
          // 使用浏览器原生confirm弹窗，简化提示信息
          if (confirm('是否使用剪切板内容创建新文件？')) {
            // 用户确认后创建新文件
            doImportClipboard(text);
          }
        })
        .catch(err => {
          console.error('无法读取剪切板:', err);
          // 提供更具体的错误信息
          if (err.name === 'NotAllowedError') {
            showToast('需要权限才能访问剪贴板，请确保应用在安全环境中运行');
          } else {
            showToast('读取剪切板失败，请重试或手动粘贴内容');
          }
        });
    }
    
    // 执行导入剪切板操作 - 修改为总是创建新文件并使用第一行作为文件名
    function doImportClipboard(text) {
      const timestamp = new Date().getTime();
      
      // 获取文本的第一行作为文件名
      const firstLine = text.split('\n')[0].trim();
      
      // 处理文件名，去除特殊字符，限制长度
      let fileName = sanitizeFileName(firstLine);
      
      // 如果第一行处理后为空或太短，使用默认名称
      if (!fileName || fileName.length < 2) {
        fileName = `新备忘录_${timestamp}`;
      }
      
      // 检查文件名是否已存在，如果存在则添加序号
      let finalFileName = fileName;
      let counter = 1;
      while (appData.files[finalFileName]) {
        finalFileName = `${fileName}_${counter}`;
        counter++;
      }
      
      // 创建新文件
      appData.files[finalFileName] = {
        content: text,
        lastModified: timestamp
      };
      
      // 保存数据
      saveDataToLocalStorage();
      
      // 打开新创建的文件
      openFile(finalFileName);
      
      // 显示成功提示
      showToast(`已从剪切板创建新文件: ${finalFileName}`);
    }
    
    // 清理文件名字符，去除不允许的字符
    function sanitizeFileName(name) {
      // 去除路径分隔符和其他不允许的字符
      // 只保留字母、数字、中文和常见标点符号
      return name.replace(/[\\/:*?"<>|]/g, '').trim()
        // 限制文件名长度，防止过长
        .substring(0, 50);
    }
    
    // 解析地址内容
    function parseAddressContent(content) {
      if (!content) return [];
      
      // 按空行分割地址段
      const addressBlocks = content.split(/\n{2,}/).filter(block => block.trim());
      
      return addressBlocks.map(block => {
        const lines = block.split('\n').filter(line => line.trim());
        if (lines.length === 0) return null;
        
        const address = lines[0].trim();
        const notes = lines.slice(1).join('\n').trim();
        
        return {
          address,
          notes,
          // 生成首字母索引
          pinyinIndex: generatePinyinIndex(address)
        };
      }).filter(item => item !== null);
    }
    
    // 生成地址的拼音索引
    function generatePinyinIndex(address) {
      if (!address) return '';
      
      // 提取中文部分
      const chineseChars = address.replace(/[^\u4e00-\u9fa5]/g, '');
      if (!chineseChars) return '';
      
      // 生成拼音首字母
      const pinyin = pinyinPro.pinyin(chineseChars, {
        pattern: 'first',
        type: 'array',
        toneType: 'none',
        v: true // 使用v代替ü
      });
      
      // 生成完整首字母串
      return pinyin.join('').toLowerCase();
    }
    
    // 为搜索优化的拼音索引生成函数
    function generateSearchableIndexes(address) {
      if (!address) return [];
      
      // 获取完整地址的拼音索引
      const fullIndex = generatePinyinIndex(address);
      const indexes = [fullIndex, address.toLowerCase()];
      
      // 为词语生成索引
      const words = splitAddressIntoWords(address);
      words.forEach(word => {
        const wordIndex = generatePinyinIndex(word);
        if (wordIndex && !indexes.includes(wordIndex)) {
          indexes.push(wordIndex);
        }
        // 同时添加词语本身
        const wordLower = word.toLowerCase();
        if (!indexes.includes(wordLower)) {
          indexes.push(wordLower);
        }
      });
      
      return indexes;
    }
    
    // 将地址拆分为词语
    function splitAddressIntoWords(address) {
      if (!address) return [];
      
      // 简单的地址拆分逻辑
      // 实际应用中可以使用更复杂的分词库
      const words = [];
      
      // 添加完整地址
      words.push(address);
      
      // 按常见地址分隔符拆分
      const separators = ['省', '市', '区', '县', '镇', '乡', '村', '路', '街', '巷', '号', '室', '单元', '栋', '层'];
      let tempAddress = address;
      
      separators.forEach(sep => {
        const parts = tempAddress.split(sep);
        if (parts.length > 1) {
          parts.forEach(part => {
            if (part.trim()) {
              words.push(part.trim() + sep);
            }
          });
          tempAddress = parts[parts.length - 1];
        }
      });
      
      // 添加地址中的每个词（2-4个字符）
      for (let i = 0; i < address.length; i++) {
        for (let j = 2; j <= 4; j++) {
          if (i + j <= address.length) {
            const word = address.substr(i, j);
            // 只添加包含中文的词
            if (/[\u4e00-\u9fa5]/.test(word)) {
              words.push(word);
            }
          }
        }
      }
      
      // 去重并返回
      return [...new Set(words)];
    }
    
    // 搜索地址 - 优化版本
    function searchAddresses(addresses, query) {
      if (!query) return addresses;
      
      // 预处理查询，移除非字母字符
      const cleanQuery = query.toLowerCase().trim();
      
      // 使用缓存来避免重复计算
      const searchCache = new Map();
      
      return addresses.filter(item => {
        // 检查缓存
        if (searchCache.has(item.address)) {
          return searchCache.get(item.address);
        }
        
        // 计算匹配结果
        let isMatch = false;
        
        // 快速检查：完整首字母匹配和直接地址匹配
        if (item.pinyinIndex.includes(cleanQuery) || item.address.toLowerCase().includes(cleanQuery)) {
          isMatch = true;
        } else {
          // 检查地址中的每个词语 - 使用更高效的方式
          const words = splitAddressIntoWords(item.address);
          isMatch = words.some(word => {
            const wordPinyin = generatePinyinIndex(word);
            return wordPinyin.includes(cleanQuery) || word.toLowerCase().includes(cleanQuery);
          });
        }
        
        // 缓存结果
        searchCache.set(item.address, isMatch);
        return isMatch;
      });
    }
    


    
    // 确认弹窗相关函数已删除，改用浏览器原生confirm
    
    // 显示提示消息
    function showToast(message) {
      elements.toastMessage.textContent = message;
      elements.toast.classList.remove('hidden');
      
      setTimeout(() => {
        elements.toast.classList.add('hidden');
      }, 2000);
    }
    
    // 处理iOS设备上的窗口大小变化，更新高度
    function updateLayoutForIOS() {
      // 获取实际可用视口高度（不包含地址栏）
      const viewportHeight = window.innerHeight;
      document.documentElement.style.setProperty('--available-height', `${viewportHeight}px`);
      
      // 更新主内容区域的底部内边距，确保不被底部工具栏遮挡
      const mainElement = document.querySelector('main');
      const footerElement = document.querySelector('footer');
      if (mainElement && footerElement) {
        const footerHeight = footerElement.offsetHeight;
        mainElement.style.paddingBottom = `${footerHeight + 20}px`; // 额外增加20px的间距
      }
    }
    
    // 监听窗口大小变化和滚动事件，处理地址栏显示/隐藏
    window.addEventListener('resize', updateLayoutForIOS);
    window.addEventListener('scroll', updateLayoutForIOS);
    window.addEventListener('orientationchange', updateLayoutForIOS);
    
    // 注册Service Worker
    if ('serviceWorker' in navigator) {
      // 使用setTimeout确保DOM完全加载
      setTimeout(() => {
        navigator.serviceWorker.register('service-worker.js')
          .then((registration) => {
            console.log('Service Worker 注册成功:', registration.scope);
            
            // 检查更新
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // 有新版本可用，可以提示用户刷新
                  console.log('有新版本可用，请刷新页面');
                }
              });
            });
          })
          .catch((error) => {
            console.log('Service Worker 注册失败，这在开发环境中是正常的:', error);
          });
      }, 1000);
    }
    
    // 处理安装事件
    let deferredPrompt;
    window.addEventListener('beforeinstallprompt', (e) => {
      // 阻止Chrome 67及更早版本自动显示安装提示
      e.preventDefault();
      // 保存事件以便稍后触发
      deferredPrompt = e;
      // 可以在这里显示自定义的安装按钮
      console.log('应用可以被安装');
    });
    
    // 阻止iOS橡皮筋效果，同时允许搜索结果列表滚动
    function preventRubberBandEffect() {
      document.body.addEventListener('touchmove', function(e) {
        // 如果滚动目标是搜索结果列表，允许滚动
        if (e.target.closest('#search-results-list')) {
          return;
        }
        // 对于其他元素，如果已经滚动到顶部或底部，阻止默认滚动
        if (e.touches.length === 1) {
          if ((window.scrollY === 0 && e.touches[0].clientY > e.changedTouches[0].clientY) ||
              (document.documentElement.scrollHeight - window.innerHeight - window.scrollY === 0 && 
               e.touches[0].clientY < e.changedTouches[0].clientY)) {
            e.preventDefault();
          }
        }
      }, { passive: false });
    }

    // 初始化应用
    document.addEventListener('DOMContentLoaded', () => {
      // 先更新布局再初始化应用
      updateLayoutForIOS();
      // 添加iOS橡皮筋效果阻止
      preventRubberBandEffect();
      // 延迟初始化以确保所有尺寸计算正确
      setTimeout(initApp, 100);
    });
  </script>


</body></html>